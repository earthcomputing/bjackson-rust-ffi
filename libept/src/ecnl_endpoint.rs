/* automatically generated by rust-bindgen */
/* edited */

#[allow(non_snake_case)]
#[allow(unused)]
pub mod ept {

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buf_desc_t {
    pub len: u32,
    pub frame: *mut u8,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecnl_endpoint_t {
    pub ept_module_id: u32,
    pub ept_sock: *const ::std::os::raw::c_void,
    pub ept_esock: *const ::std::os::raw::c_void,
    pub ept_name: *const ::std::os::raw::c_char,
    pub ept_port_id: u32,
    pub ept_up_down: ::std::os::raw::c_int,
}

unsafe impl Send for ecnl_endpoint_t {}
unsafe impl Sync for ecnl_endpoint_t {}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecnl_event_t {
    pub event_module_id: u32,
    pub event_port_id: u32,
    pub event_cmd_id: ::std::os::raw::c_int,
    pub event_n_msgs: u32,
    pub event_up_down: ::std::os::raw::c_int,
}

#[link(name = ":ecnl_endpoint.o")]
#[link(name = ":ecnl_proto.o")]
#[link(name = ":libnl-3.so")]
#[link(name = ":libnl-genl-3.so")]

extern "C" {
    pub fn ecnl_init(debug: bool) -> ::std::os::raw::c_int;
    pub fn ept_create(port_id: u32) -> *const ecnl_endpoint_t;
    pub fn ept_destroy(ept: *const ecnl_endpoint_t);

    pub fn ept_do_read_async(ept: *const ecnl_endpoint_t, actual_buf: *mut buf_desc_t);
    pub fn ept_do_read(ept: *const ecnl_endpoint_t, actual_buf: *mut buf_desc_t, nsecs: ::std::os::raw::c_int);
    pub fn ept_do_xmit(ept: *const ecnl_endpoint_t, buf: *mut buf_desc_t);
    pub fn ept_update(ept: *const ecnl_endpoint_t);

    pub fn ept_get_event(ept: *const ecnl_endpoint_t, event: *mut ecnl_event_t);

    pub fn ept_dumpbuf(ept: *const ecnl_endpoint_t, tag: *const ::std::os::raw::c_char, buf: *mut buf_desc_t);
}

}
